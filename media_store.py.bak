from __future__ import annotations

import base64
import binascii
import io
import os
import re
import time
from datetime import datetime, timezone
from typing import Optional, Tuple
from urllib.parse import unquote_to_bytes

import boto3
import cairosvg

S3 = boto3.client("s3")

MEDIA_BUCKET = os.getenv("MEDIA_S3_BUCKET") or os.getenv("QUEUE_S3_BUCKET") or ""
MEDIA_PREFIX = os.getenv("MEDIA_S3_PREFIX", "social/generated/")  # e.g., social/generated/

DATAURL_RE = re.compile(
    r"^data:(?P<mime>[^;,]+)(;charset=[^;,]+)?(?P<b64>;base64)?,(?P<data>.*)$",
    re.IGNORECASE | re.DOTALL,
)


class MediaError(RuntimeError):
    pass


def _now_ts() -> str:
    return datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")


def _slug(s: str, max_words: int = 4) -> str:
    words = re.findall(r"[a-zA-Z0-9]+", s.lower())
    return "-".join(words[:max_words]) or f"media-{int(time.time())}"


def parse_data_url(data_url: str) -> Tuple[str, bytes]:
    """
    Parse a data: URL and return (mime_type, bytes).
    Supports base64 and url-encoded text payloads.
    """
    m = DATAURL_RE.match(data_url.strip())
    if not m:
        raise MediaError("Not a valid data: URL")
    mime = (m.group("mime") or "").lower()
    payload = m.group("data") or ""
    if m.group("b64"):
        try:
            return mime, base64.b64decode(payload, validate=True)
        except binascii.Error as e:
            raise MediaError(f"Invalid base64 in data URL: {e}")
    return mime, unquote_to_bytes(payload)


def ensure_png_or_jpeg(mime_in: str, blob: bytes, target_px: Optional[int] = 1080) -> Tuple[bytes, str]:
    """
    Convert SVG → PNG. Pass-through PNG/JPEG.
    Returns (bytes_out, mime_out).
    """
    mi = (mime_in or "").lower()
    if mi in ("image/png", "image/jpeg", "image/jpg"):
        return blob, ("image/jpeg" if mi == "image/jpg" else mi)
    if mi == "image/svg+xml":
        png = cairosvg.svg2png(bytestring=blob, output_width=target_px, output_height=target_px)
        return png, "image/png"
    raise MediaError(f"Unsupported media type in data URL: {mime_in}")


def s3_key_for_media(caption_hint: str, ext: str = ".png") -> str:
    slug = _slug(caption_hint or "media")
    yyyy = datetime.now(timezone.utc).strftime("%Y")
    mm = datetime.now(timezone.utc).strftime("%m")
    prefix = MEDIA_PREFIX if MEDIA_PREFIX.endswith("/") else MEDIA_PREFIX + "/"
    return f"{prefix}{yyyy}/{mm}/trusect-{slug}-{_now_ts()}{ext}"


def upload_bytes_to_s3(body: bytes, content_type: str, key: str) -> str:
    if not MEDIA_BUCKET:
        raise MediaError("MEDIA_S3_BUCKET or QUEUE_S3_BUCKET must be set")
    S3.put_object(Bucket=MEDIA_BUCKET, Key=key, Body=body, ContentType=content_type)
    return key


def presign_s3(key: str, expires: int = 3600) -> str:
    if not MEDIA_BUCKET:
        raise MediaError("MEDIA_S3_BUCKET or QUEUE_S3_BUCKET must be set")
    return S3.generate_presigned_url(
        "get_object",
        Params={"Bucket": MEDIA_BUCKET, "Key": key},
        ExpiresIn=expires,
    )


def ingest_data_url_to_s3(data_url: str, caption_hint: str = "") -> Tuple[str, str]:
    """
    Accepts a data: URL, converts SVG→PNG if needed, uploads to S3.
    Returns (s3_key, mime_out).
    """
    mime_in, blob = parse_data_url(data_url)
    bytes_out, mime_out = ensure_png_or_jpeg(mime_in, blob, target_px=1080)
    ext = ".png" if mime_out == "image/png" else ".jpg"
    key = s3_key_for_media(caption_hint, ext=ext)
    upload_bytes_to_s3(bytes_out, mime_out, key)
    return key, mime_out

